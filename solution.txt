where i have used ai & google: 


preparing all veriable as configurations 
tf  : tick frequency , no of times fireflies clocks tick per second so 1/tf is precision of system.
n   : input parameter, number of fireflies, we have to create n processes representing n fireflies.
pf  : print frequency, print all fireflies in a line pf/second and before printing the line clear the previous line so at a time only one line is visible on screen
  -- below time values are expected in seconds unit --
oft : off time for which fireflies will be in off start after which they will switch state and trun on
ont : on time for which fireflies will in on state after which they will switch state to turn off
dt  : delta time max skip wait time , which fireflies can skip like if fireflies needs to wait for w time to swich on and they get a on ping from left side then they can skip wait for min(w, dt) which will cause them to switch on little earlier


refrance conversion:
here i want to deal with standerd integer values for time 
so first of all calculating the precision from tf since clocks tick tf time per second 

Assumption : considering miliseond precision

unit time ut = 1000/tf  (smallest time quantum of system in ms)

now convert each time values oft, ont, dt  to ut refrance basically since ut is minimum measurable time so all time will measured in system will be mutiple of ut
so standerd oft, ont and dt will be as follows:
soft =  1000*oft / ut
sont =  1000*ont / ut
sdt  =  1000*dt / ut


before spawing fireflies we will spawn printer and broadcaster and pass it pid to fireflies
so each fire fly know about existance of a printer( which queries them for their state)
and broadcaster (which tells them some fly has just turned on)

for n fireflies we will spawn n process each process will have following things:

    id         : int value starting from 1 to n
    clock      : it's basically a counter which increments value by 1 after each ut interval
    state      : 0 or 1  (zero means off 1 means on)
        -- and same above parameter values --
    ut             : unit time in miliseconds
    soft           : off time (int multiple of ut)
    sont           : on time (int multiple of ut)
    sdt            : delta (int multiple of ut) which can be skipped
    pid            : self()   process id
    printer_id     : when a fly created it will have this printer_id as parameter and pinter can ping fly on {:get_state} and when fly is created we send a ping to printer in this way printer can store the list of all flies which helps it to query state of every fly
    broadcaster_id : all fly will have pid of this broadcaster, simialr to printer it will maintain a list of flies which will help it broadcast to all flies. and flies can ping broadcaster to notify other fly about his on state.


intial condition :
intially all firefly is on off state 
and each firefly's clock is set to some random float value from [0 to 2*tf ]   (between 0 to 2 sec)

for flaot : 
clock: :rand.uniform(max_random_time),

for int :
trunc(:rand.uniform(max_random_time)),



each process have clock, in intial state values might contain decimal fractions but after first sync it will natural number always

update_state : 
when in off state and clock >= soft  it chnages the state to on and clock resets to 0 and when it changes state at t=0 it broadcasts it's id {:on_state, self.id} to every one
when in on state  and clock >= sont  it changes the state to off state and clock resets to 0


update_clock logic : 
if state  == 0  # off state
  when recieves any broadcasts {:on_state , firefly_id}  if left_neighbour then add +sdt in clock 
if state  == 1
  do nothing


tick: 
  just add one to clock


broadcast:
  it is process which collects the pids of all flies during creation and help flies to send pings to other flies without knowing each other

printer :
    it is process which collects the pids of all flies during creation and query flies at a regular interval for printing state on terminal


run_firefly
  listner : 
    actively keeps listing and checks for skip wait time condition be be met and increase it's clock
  manager_clock :
    after regular intervals increment the clock by 1 unit

on each clock ticks & skip_wait event state chnage logic is checked and state is updated and clocks are set to zero.
if new state is on state
just after state change execution at clock = 0  broadcasts will be done to all other fireflies












---------------------------------------------------------------------------------------
EDGE cases : 
so let's say unit time is 100ms so if nothing happens then after 100ms tick will triiger and increment the counter 
well and good

now consider this :
let's say value of clock just changes to 2 and from it's left neighbour a ping came after 2 ms of so it adds 
let's say 3 unit of time so now it's at 6 unit but since he already spend 2 ms in current wait so he needed to wait 98 ms to complete the normal cycle but now he will go to next cycle which is not in perfect 100ms slot are you getting me ?

normal :
200ms    300ms   400ms   500ms 600ms
tick     tick    tick    tick    tick

when ping :
200ms   202ms (ping) 502ms  602ms  602ms
tick    jump         tick   tick    tick


sapreated the clock_update and skip_wait logic as a indepenent flow and clock_update will get precedence 

to maintain to avoid time slip by different clocks now all of the regular clocks will tick at the same time







two process
 
 create fire fly 
  cid 
  lid 

  listner 
    : clock_tick
    : printer_get_state
    : on_state. 
  
  clock will have listner_id
    : 
   
  


 clock.             listner    t
            ->                1
                              2
                              3
                              4
                              5    